var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import reduce from 'lodash/reduce';
import forEach from 'lodash/forEach';
import find from 'lodash/find';
import get from 'lodash/get';
import keys from 'lodash/keys';
import uniq from 'lodash/uniq';
import mapKeys from 'lodash/mapKeys';
import mapValues from 'lodash/mapValues';
import curry from 'lodash/curry';
import hogan from 'hogan.js';

export { getContainerNode, bemHelper, prepareTemplateProps, renderTemplate, isSpecialClick, isDomElement, getRefinements, getAttributesToClear, clearRefinements, prefixKeys, escapeRefinement, unescapeRefinement, checkRendering, isReactElement, deprecate, parseAroundLatLngFromString };

/**
 * Return the container. If it's a string, it is considered a
 * css selector and retrieves the first matching element. Otherwise
 * test if it validates that it's a correct DOMElement.
 * @param {string|HTMLElement} selectorOrHTMLElement a selector or a node
 * @return {HTMLElement} The resolved HTMLElement
 * @throws Error when the type is not correct
 */
function getContainerNode(selectorOrHTMLElement) {
  var isFromString = typeof selectorOrHTMLElement === 'string';
  var domElement = void 0;
  if (isFromString) {
    domElement = document.querySelector(selectorOrHTMLElement);
  } else {
    domElement = selectorOrHTMLElement;
  }

  if (!isDomElement(domElement)) {
    var errorMessage = 'Container must be `string` or `HTMLElement`.';
    if (isFromString) {
      errorMessage += ' Unable to find ' + selectorOrHTMLElement;
    }
    throw new Error(errorMessage);
  }

  return domElement;
}

/**
 * Returns true if the parameter is a DOMElement.
 * @param {any} o the value to test
 * @return {boolean} true if o is a DOMElement
 */
function isDomElement(o) {
  return o instanceof window.HTMLElement || Boolean(o) && o.nodeType > 0;
}

function isSpecialClick(event) {
  var isMiddleClick = event.button === 1;
  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
}

/**
 * Creates BEM class name according the vanilla BEM style.
 * @param {string} block the main block
 * @return {function} function that takes up to 2 parameters
 * that determine the element and the modifier of the BEM class.
 */
function bemHelper(block) {
  return function (element, modifier) {
    // block--element
    if (element && !modifier) {
      return block + '--' + element;
    }
    // block--element__modifier
    if (element && modifier) {
      return block + '--' + element + '__' + modifier;
    }
    // block__modifier
    if (!element && modifier) {
      return block + '__' + modifier;
    }

    return block;
  };
}

/**
 * Prepares an object to be passed to the Template widget
 * @param {object} unknownBecauseES6 an object with the following attributes:
 *  - transformData
 *  - defaultTemplate
 *  - templates
 *  - templatesConfig
 * @return {object} the configuration with the attributes:
 *  - transformData
 *  - defaultTemplate
 *  - templates
 *  - useCustomCompileOptions
 */
function prepareTemplateProps(_ref) {
  var transformData = _ref.transformData,
      defaultTemplates = _ref.defaultTemplates,
      templates = _ref.templates,
      templatesConfig = _ref.templatesConfig;

  var preparedTemplates = prepareTemplates(defaultTemplates, templates);

  return _extends({
    transformData: transformData,
    templatesConfig: templatesConfig
  }, preparedTemplates);
}

function prepareTemplates() {
  var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var allKeys = uniq([].concat(_toConsumableArray(keys(defaultTemplates)), _toConsumableArray(keys(templates))));

  return reduce(allKeys, function (config, key) {
    var defaultTemplate = defaultTemplates[key];
    var customTemplate = templates[key];
    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;

    config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;
    config.useCustomCompileOptions[key] = isCustomTemplate;

    return config;
  }, { templates: {}, useCustomCompileOptions: {} });
}

function renderTemplate(_ref2) {
  var templates = _ref2.templates,
      templateKey = _ref2.templateKey,
      compileOptions = _ref2.compileOptions,
      helpers = _ref2.helpers,
      data = _ref2.data;

  var template = templates[templateKey];
  var templateType = typeof template === 'undefined' ? 'undefined' : _typeof(template);
  var isTemplateString = templateType === 'string';
  var isTemplateFunction = templateType === 'function';

  if (!isTemplateString && !isTemplateFunction) {
    throw new Error('Template must be \'string\' or \'function\', was \'' + templateType + '\' (key: ' + templateKey + ')');
  }

  if (isTemplateFunction) {
    return template(data);
  }

  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);

  return hogan.compile(template, compileOptions).render(_extends({}, data, {
    helpers: transformedHelpers
  }));
}

// We add all our template helper methods to the template as lambdas. Note
// that lambdas in Mustache are supposed to accept a second argument of
// `render` to get the rendered value, not the literal `{{value}}`. But
// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).
function transformHelpersToHogan(helpers, compileOptions, data) {
  return mapValues(helpers, function (method) {
    return curry(function (text) {
      var _this = this;

      var render = function render(value) {
        return hogan.compile(value, compileOptions).render(_this);
      };
      return method.call(data, text, render);
    });
  });
}

function getRefinement(state, type, attributeName, name, resultsFacets) {
  var res = { type: type, attributeName: attributeName, name: name };
  var facet = find(resultsFacets, { name: attributeName });
  var count = void 0;
  if (type === 'hierarchical') {
    var facetDeclaration = state.getHierarchicalFacetByName(attributeName);
    var split = name.split(facetDeclaration.separator);
    res.name = split[split.length - 1];
    for (var i = 0; facet !== undefined && i < split.length; ++i) {
      facet = find(facet.data, { name: split[i] });
    }
    count = get(facet, 'count');
  } else {
    count = get(facet, 'data["' + res.name + '"]');
  }
  var exhaustive = get(facet, 'exhaustive');
  if (count !== undefined) {
    res.count = count;
  }
  if (exhaustive !== undefined) {
    res.exhaustive = exhaustive;
  }
  return res;
}

function getRefinements(results, state, clearsQuery) {
  var res = clearsQuery && state.query && state.query.trim() ? [{
    type: 'query',
    name: state.query,
    query: state.query
  }] : [];

  forEach(state.facetsRefinements, function (refinements, attributeName) {
    forEach(refinements, function (name) {
      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));
    });
  });

  forEach(state.facetsExcludes, function (refinements, attributeName) {
    forEach(refinements, function (name) {
      res.push({ type: 'exclude', attributeName: attributeName, name: name, exclude: true });
    });
  });

  forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {
    forEach(refinements, function (name) {
      res.push(getRefinement(state, 'disjunctive', attributeName,
      // we unescapeRefinement any disjunctive refined value since they can be escaped
      // when negative numeric values search `escapeRefinement` usage in code
      unescapeRefinement(name), results.disjunctiveFacets));
    });
  });

  forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {
    forEach(refinements, function (name) {
      res.push(getRefinement(state, 'hierarchical', attributeName, name, results.hierarchicalFacets));
    });
  });

  forEach(state.numericRefinements, function (operators, attributeName) {
    forEach(operators, function (values, operator) {
      forEach(values, function (value) {
        res.push({
          type: 'numeric',
          attributeName: attributeName,
          name: '' + value,
          numericValue: value,
          operator: operator
        });
      });
    });
  });

  forEach(state.tagRefinements, function (name) {
    res.push({ type: 'tag', attributeName: '_tags', name: name });
  });

  return res;
}

/**
 * Clears the refinements of a SearchParameters object based on rules provided.
 * The white list is first used then the black list is applied. If no white list
 * is provided, all the current refinements are used.
 * @param {object} $0 parameters
 * @param {Helper} $0.helper instance of the Helper
 * @param {string[]} [$0.whiteList] list of parameters to clear
 * @param {string[]} [$0.blackList=[]] list of parameters not to remove (will impact the white list)
 * @param {boolean} [$0.clearsQuery=false] clears the query if need be
 * @returns {SearchParameters} search parameters with refinements cleared
 */
function clearRefinements(_ref3) {
  var helper = _ref3.helper,
      whiteList = _ref3.whiteList,
      _ref3$blackList = _ref3.blackList,
      blackList = _ref3$blackList === undefined ? [] : _ref3$blackList,
      _ref3$clearsQuery = _ref3.clearsQuery,
      clearsQuery = _ref3$clearsQuery === undefined ? false : _ref3$clearsQuery;

  var attributesToClear = getAttributesToClear({
    helper: helper,
    whiteList: whiteList,
    blackList: blackList
  });

  var finalState = helper.state;

  attributesToClear.forEach(function (attribute) {
    if (attribute === '_tags') {
      finalState = finalState.clearTags();
    } else {
      finalState = finalState.clearRefinements(attribute);
    }
  });

  if (clearsQuery) {
    finalState = finalState.setQuery('');
  }

  return finalState;
}

/**
 * Computes the list of attributes (conjunctive, disjunctive, hierarchical facet + numerical attributes)
 * to clear based on a optional white and black lists. The white list is applied first then the black list.
 * @param {object} $0 parameters
 * @param {Helper} $0.helper instance of the Helper
 * @param {string[]} [$0.whiteList] attributes to clear (defaults to all attributes)
 * @param {string[]} [$0.blackList=[]] attributes to keep, will override the white list
 * @returns {string[]} the list of attributes to clear based on the rules
 */
function getAttributesToClear(_ref4) {
  var helper = _ref4.helper,
      whiteList = _ref4.whiteList,
      blackList = _ref4.blackList;

  var lastResults = helper.lastResults || {};
  var attributesToClear = whiteList || getRefinements(lastResults, helper.state).map(function (one) {
    return one.attributeName;
  });

  return attributesToClear.filter(function (attribute) {
    return blackList.indexOf(attribute) === -1;
  });
}

function prefixKeys(prefix, obj) {
  if (obj) {
    return mapKeys(obj, function (v, k) {
      return prefix + k;
    });
  }

  return undefined;
}

function escapeRefinement(value) {
  if (typeof value === 'number' && value < 0) {
    value = String(value).replace(/^-/, '\\-');
  }

  return value;
}

function unescapeRefinement(value) {
  return String(value).replace(/^\\-/, '-');
}

function checkRendering(rendering, usage) {
  if (rendering === undefined || typeof rendering !== 'function') {
    throw new Error(usage);
  }
}

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && Symbol.for && Symbol.for('react.element') || 0xeac7;

function isReactElement(object) {
  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

function deprecate(fn, message) {
  var hasAlreadyPrint = false;

  return function () {
    if (!hasAlreadyPrint) {
      hasAlreadyPrint = true;

      // eslint-disable-next-line no-console
      console.warn('[InstantSearch.js]: ' + message);
    }

    return fn.apply(undefined, arguments);
  };
}

var latLngRegExp = /^(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)$/;
function parseAroundLatLngFromString(value) {
  var pattern = value.match(latLngRegExp);

  // Since the value provided is the one send with the query, the API should
  // throw an error due to the wrong format. So throw an error should be safe..
  if (!pattern) {
    throw new Error('Invalid value for "aroundLatLng" parameter: "' + value + '"');
  }

  return {
    lat: parseFloat(pattern[1]),
    lng: parseFloat(pattern[2])
  };
}